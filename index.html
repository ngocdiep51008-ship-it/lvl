<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Interaction</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        #ui-layer { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 100; }
        .badge { display: inline-block; background: rgba(0, 0, 0, 0.7); border: 2px solid #fff3ae; color: #fff3ae; padding: 10px 25px; border-radius: 50px; font-size: 18px; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        .guide { color: #ccc; font-size: 13px; margin-bottom: 20px; text-shadow: 0 2px 4px black; }
        button { pointer-events: auto; cursor: pointer; background: linear-gradient(to bottom, #ffb6de, rgb(255, 204, 234)); color: #333; border: 2px solid #fff3ae; padding: 15px 50px; border-radius: 30px; font-weight: 800; font-size: 16px; box-shadow: 0 0 30px rgba(255, 200, 229, 0.8); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        #camera-preview { position: fixed; top: 12px; right: 12px; width: 120px; height: 90px; border-radius: 10px; border: 1.5px solid rgba(255, 255, 255, 0.4); transform: scaleX(-1); opacity: 0.8; z-index: 200; background: #000; }
    </style>
</head>

<body>
    <div id="ui-layer">
        <div id="status" class="badge">S·∫µn s√†ng</div>
        <div class="guide">
            üñê <b>X√≤e:</b> Bung Qu√† | üëå <b>Pinch:</b> Xem ·∫£nh | ‚úä <b>N·∫Øm:</b> Thu c√¢y | ü§≤ <b>2 Tay:</b> Tr√°i Tim
        </div>
        <button id="btnStart" onclick="startSystem()">B·∫ÆT ƒê·∫¶U GI√ÅNG SINH</button>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none" playsinline></video>
    <canvas id="camera-preview"></canvas>

    <script>
        // --- C·∫•u h√¨nh t√†i nguy√™n ---
        const MUSIC_URL = "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3"; // Link nh·∫°c m·∫´u, b·∫°n h√£y thay b·∫±ng file c·ªßa m√¨nh
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true;

        const loader = new THREE.TextureLoader();
        // Thay link ·∫£nh th·∫≠t v√†o ƒë√¢y (v√≠ d·ª•: 'https://picsum.photos/200')
        const photoFiles = ['./img/a1.jpg', './img/a2.jpg', './img/a3.jpg', './img/a4.jpg']; 
        const photoTextures = photoFiles.map(file => loader.load(file, undefined, undefined, (err) => console.log("L·ªói load ·∫£nh:", file)));

        // --- T·∫°o Texture th·ªß c√¥ng ---
        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            if (type === 'gold_glow') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grd.addColorStop(0, '#FFFFFF'); grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);
            } else if (type === 'red_light') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FF0000'); grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);
            } else if (type === 'gift') {
                ctx.fillStyle = '#ffc6e6'; ctx.fillRect(20, 20, 88, 88);
                ctx.fillStyle = '#fff5ba'; ctx.fillRect(54, 20, 20, 88); ctx.fillRect(20, 54, 88, 20);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = { gold: createCustomTexture('gold_glow'), red: createCustomTexture('red_light'), gift: createCustomTexture('gift') };

        // --- H·ªá th·ªëng 3D ---
        const CONFIG = { goldCount: 2000, redCount: 300, giftCount: 150, explodeRadius: 65, treeHeight: 70, treeBaseRadius: 35, heartSize: 40 };
        let scene, camera, renderer, groupGold, groupRed, groupGift, titleMesh, starMesh, loveTextMesh;
        let photoMeshes = [];
        let state = 'TREE';
        let handX = 0.5, heartRotation = 0, selectedIndex = 0;

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 120;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 1.5);
            groupRed = createParticleSystem('red', CONFIG.redCount, 2.5);
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0);

            createPhotos();
            createDecorations();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPos = [], pTree = [], pExp = [], pHeart = [];
            for (let i = 0; i < count; i++) {
                // Tree
                const h = Math.random() * CONFIG.treeHeight;
                const r = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius * (type === 'gold' ? Math.sqrt(Math.random()) : 1);
                const theta = Math.random() * Math.PI * 2;
                pTree.push(r * Math.cos(theta), h - CONFIG.treeHeight / 2, r * Math.sin(theta));
                // Explode
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random());
                const u = Math.random(), v = Math.random();
                const phi = Math.acos(2 * v - 1), lam = 2 * Math.PI * u;
                pExp.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));
                // Heart
                const t = Math.random() * Math.PI * 2;
                pHeart.push(16 * Math.pow(Math.sin(t), 3) * 2, (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 2, (Math.random() - 0.5) * 10);
                pPos.push(pTree[i*3], pTree[i*3+1], pTree[i*3+2]);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            geo.userData = { tree: pTree, explode: pExp, heart: pHeart };
            const mat = new THREE.PointsMaterial({ size, map: textures[type === 'gift' ? 'gift' : type], transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(10, 10);
            photoTextures.forEach(tex => {
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
                mesh.visible = false;
                mesh.scale.set(0, 0, 0);
                scene.add(mesh);
                photoMeshes.push(mesh);
            });
        }

        function createDecorations() {
            // Text Love
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 60px Arial'; ctx.fillStyle = '#ff3366'; ctx.textAlign = 'center';
            ctx.fillText('MUNN Y√äU LVL', 256, 80);
            loveTextMesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 12.5), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            loveTextMesh.visible = false;
            scene.add(loveTextMesh);

            // Title Merry Christmas
            const tCanvas = document.createElement('canvas');
            tCanvas.width = 512; tCanvas.height = 128;
            const tCtx = tCanvas.getContext('2d');
            tCtx.font = 'bold 50px Arial'; tCtx.fillStyle = '#FFD700'; tCtx.textAlign = 'center';
            tCtx.fillText('MERRY CHRISTMAS', 256, 80);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(tCanvas), transparent: true }));
            titleMesh.position.y = 45;
            scene.add(titleMesh);

            // Star
            starMesh = new THREE.Mesh(new THREE.SphereGeometry(3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            starMesh.position.y = CONFIG.treeHeight / 2;
            scene.add(starMesh);
        }

        function updateParticles(group, targetState) {
            const pos = group.geometry.attributes.position.array;
            const target = group.geometry.userData[targetState.toLowerCase()] || group.geometry.userData.tree;
            for (let i = 0; i < pos.length; i++) {
                pos[i] += (target[i] - pos[i]) * 0.08;
            }
            group.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            updateParticles(groupGold, state === 'PHOTO' ? 'EXPLODE' : state);
            updateParticles(groupRed, state === 'PHOTO' ? 'EXPLODE' : state);
            updateParticles(groupGift, state === 'PHOTO' ? 'EXPLODE' : state);

            if (state === 'TREE') {
                titleMesh.visible = true; starMesh.visible = true; loveTextMesh.visible = false;
                photoMeshes.forEach(m => m.visible = false);
                scene.rotation.y += 0.01;
            } else if (state === 'HEART') {
                titleMesh.visible = false; starMesh.visible = false; loveTextMesh.visible = true;
                loveTextMesh.lookAt(camera.position);
                scene.rotation.y = 0;
            } else if (state === 'EXPLODE' || state === 'PHOTO') {
                titleMesh.visible = false; starMesh.visible = false;
                photoMeshes.forEach((m, i) => {
                    m.visible = true;
                    if (state === 'PHOTO' && i === selectedIndex) {
                        m.position.lerp(new THREE.Vector3(0, 0, 70), 0.1);
                        m.scale.lerp(new THREE.Vector3(4, 4, 4), 0.1);
                    } else {
                        const angle = (i / photoMeshes.length) * Math.PI * 2 + time;
                        m.position.lerp(new THREE.Vector3(Math.cos(angle) * 40, Math.sin(time) * 5, Math.sin(angle) * 40), 0.1);
                        m.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    }
                    m.lookAt(camera.position);
                });
            }

            renderer.render(scene, camera);
        }

        // --- H·ªá th·ªëng MediaPipe ---
        async function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play();
            init3D();

            const video = document.querySelector('.input_video');
            const canvasElement = document.getElementById('camera-preview');
            const canvasCtx = canvasElement.getContext('2d');
            const statusDiv = document.getElementById('status');

            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults((results) => {
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    if (results.multiHandLandmarks.length === 2) {
                        state = 'HEART';
                        statusDiv.innerText = "√îm C·∫≠u ‚ù£Ô∏è";
                    } else {
                        const lm = results.multiHandLandmarks[0];
                        const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        const open = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);

                        if (pinch < 0.05) {
                            state = 'PHOTO'; statusDiv.innerText = "Xem ·∫¢nh üíñ";
                        } else if (open > 0.4) {
                            state = 'EXPLODE'; statusDiv.innerText = "Bung Qu√† üíù";
                        } else {
                            state = 'TREE'; statusDiv.innerText = "Gi√°ng Sinh An L√†nh";
                        }
                    }
                }
                canvasCtx.restore();
            });

            const cameraHelper = new Camera(video, {
                onFrame: async () => { await hands.send({ image: video }); },
                width: 320, height: 240
            });
            cameraHelper.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>